% !TEX root = ../thesis.tex
\chapter{Context-Aware Data Mashups: Concepts, Goals and Requirements}
\label{capitolo3}
\thispagestyle{empty}

\section{Concepts}
\subsection{Introducing CAMUS}
Context-Aware Data MashUpS (CAMUS)\cite{camus} is a project that aims to create a framework capable of performing seamless data integration obtained from multiple heterogeneous sources, and then apply context-based filtering to this data. The result of this process is a collection of resources that is context-aware; in other words, it takes into account the particular details of the user requesting this information. Moreover, this data integrates the different responses received from the various sources, whether they are online web services, or locally stored data.\\\\
The CAMUS project is split into multiple components, each having its own purpose and functionality. Moreover, there are multiple human agents involved in operating the system, each of them with their own roles and responsibilities which we will shortly explain. The main components on the CAMUS system are the end-user interface, the context dimension tree, the resource schema, and finally the backend server. On the other hand, the human agents who are involved in this system are the end user, the middle agent, and the system administrator.\\\\\\
The following figure shows the basic operational flow of the CAMUS system.
\begin{figure}[h]
\includegraphics[width=\textwidth]{camus}
\caption{CAMUS Flow}
\end{figure}
\subsubsection{The End-User Application}
The end-user interface represents the mobile application installed on the mobile devices of the users. This mobile application used as a two-way portal that both displays relevant information that users ask for, as well as take input from the users to further improve the user experience. During the initial setup phase, the end-user (the tourist in the our example) provides as many details about his needs and preferences. These details will be used to describe the ``context'' of the user, along with other parameters that can be collected real-time while they use the application. The travel agent takes the information provided by tourist, and using a web interface, inputs this information into the system.
\subsubsection{The Context-Dimension Tree (CDT)}
The web interface used by the travel agent is generated based on the context dimension tree. This tree is a representation of the various parameters that are part of a user's context for a given topic. In our example, a user's favorite cuisines, their allergies, and their ambience preference (indoors vs. outdoors) are some of factors that constitute the CDT for the ``Restaurants'' topic. The system administrator initially constructs the tree, and the web interface is the mean through which the middle agent can input the values provided by the end-user.
\subsubsection{The Resource Schema}
The resource schema describes the various topics supported by CAMUS; in other words, it includes the attributes associated with a topic. For example, the resource schema specifies that the ``Restaurant'' structure includes attributes such as name, address, phone number, cuisines, rating, and so on. A mapping function takes care of matching these attributes with the CDT, and this operation is what transforms a context-agnostic request into a context-aware one. The system administrator is the one responsible of defining and updating the resource schema when needed.
\subsubsection{The Backend Server}
The final component of the CAMUS framework is the backend server. This component's task is to perform the actual querying of the various web services when required by the middleware. The middleware receives queries from the end-user application or from the middle agent, and performs the mapping between the CDT and the resource schema if needed. Then, the queries are forwarded to the backend server. This server then identifies which web services to query, sends the requests, and parses the responses. This server is also responsible of performing the data integration operations, transforming the heterogeneous output of the various web services into a homogeneous list that is made accessible to the middleware.
\subsection{Homogeneity vs. Heterogeneity}
Two or more data sets are considered homogenous when they made up of elements that belong to the same type. In other words, all of the elements that make up the data sets share the same structure. The simplest example of a homogenous data set is an array, since generally, all of the elements of an array belong to the same type. Therefore, two integer arrays are homogenous. Conversely, heterogeneous data sets are data sets that contain differently structured elements such as lists and unions, among others.\\\\
Naturally, different online services have their own structures for the objects that they return when they receive requests. This is even true for different services that operate in the same domain. For instance, two APIs specializing in food and restaurants reply differently, even if we call a simple search API that returns a list of restaurants. Even though conceptually both APIs are returning a list of restaurants, each API returns different attributes, and therefore the Restaurant objects are not identical. It does not stop at that: even the general structure of the reply, the meta information returned along with the restaurants list, and the names of the fields are different.

\section{Goals and Requirements}

Our primary goal in this is to find a way to extract the useful information from the aforementioned heterogeneous replies, therefore ending up with a homogenous structure (in this example, an array of restaurants), and this array will have in it all of the restaurants that were included in the various received replies. The process should also be flexible, in the sense that we should have the ability to add more services, and the algorithm should be able to include the results from the new service without making changes to the core of the code. Instead, we would just have to include a description that specifies details about the new service (what parameters it expects, and the structure of its reply).\\\\
Another primary concern is to reduce the waiting time on the side of the end user: sending numerous requests to multiple web services, receiving the replies, and parsing these replies can take a lot of time. Therefore, we should aim to reduce the number of sent requests if possible. Mobile application users however do not expect long wait times when performing seemingly simple functions such as searching for a place to eat, and therefore we should be able to provide them with results as soon as possible.\\\\
Additionally, we have to include the context awareness paradigm to our workflow: the results that the user sees on their device should be filtered according to their own context. In some cases, the filtering can be done before sending the request to the web services, by making use of the request parameters that are sent along with the request. However, there will be some attributes in the replies that we might want to filter against, even though the web service does not support such filters as part of the request parameters. In this case, we should filter the results after the responses are received, and before we forward them to the user.\\\\
Context awareness should be included in all of the operational phases of our system. Firstly, selecting which web services to query is made context-aware by choosing services that allow filtering, or include information that match with the parameters that make up our context. These parameters are determined on a case-by-case basis, and therefore, so should be the selected services.\\\\
Going to a lower level, the data returned by the services can be enriched with the user's context by making sure that the query parameters of the requests that are being sent to the web services represent as accurately as possible the user's context. In order to do so, each individual API that we are querying should be closely examined, and we should make sure that we are on one hand optimizing the values attached to the query, and that we are taking advantage of all of the supported filtering parameters offered by the web service on the other hand.\\\\
Further filtering should be done after the services send their replies: we are bound to encounter services that do are not as flexible as we need them to be in terms of allowing filtering within the request parameters. In that case, we should examine all of the fields returned by these services, and make sure that context-based filtering is performed also on these responses when needed. Finally, we should also allow the end-user to provide manually additional filters, to account for changes in the context, or simply to give the user more freedom. This would create a truly dynamic, context-aware output that matches the user's needs as accurately as possible.\\\\
In order to allow users of CAMUS to easily integrate new services, we should provide an intuitive frontend which can be used to describe new services, and associate them with their respective topics. The same applies to filling a user's information in the CDT, especially that this task should be doable by an individual who does not possess any programming or technical knowledge. Moreover, the system should take into account that the information that was provided as input to the CDT might change over time, and therefore, the implementation should be dynamic enough to allow changes to the CDT, and update the output shown to the users accordingly.\\\\
